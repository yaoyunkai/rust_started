借用（borrowing）、slice 以及 Rust 如何在内存中布局数据。


所有权 ownership

在像 Rust 这样的系统编程语言中，值是位于栈上还是堆上在更大程度上影响了语言的行为以及为何必须做出这样的抉择。

所有权的主要目的就是为了管理堆数据
在编译时大小未知或大小可能变化的数据，要改为存储在堆上

规则：
    Rust 中的每一个值都有一个 所有者（owner）。
    值在任一时刻有且只有一个所有者。
    当所有者（变量）离开作用域，这个值将被丢弃。


当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop

Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制都可以被认为是对运行时性能影响较小的。

Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上

Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。

将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。

Trait: 
Drop 
Copy
Deref


-------------------------------------------------
引用 reference 

& 符号就是 引用

解引用运算符 *

引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。 
与指针不同，引用确保指向某个特定类型的有效值。

我们将创建一个引用的行为称为 借用（borrowing）

可变引用有一个很大的限制：如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用。



悬垂引用（Dangling References）

在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 悬垂指针（dangling pointer），
所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。
